{
  "version": 3,
  "sources": ["../src/memoize.js", "../src/index.ts"],
  "sourcesContent": ["//\r\n// Code from `fast-memoize`\r\n//\r\n\r\nfunction memoize(fn, options) {\r\n\tvar cache = options && options.cache ? options.cache : cacheDefault;\r\n\r\n\tvar serializer = options && options.serializer ? options.serializer : serializerDefault;\r\n\r\n\tvar strategy = options && options.strategy ? options.strategy : strategyDefault;\r\n\r\n\treturn strategy(fn, {\r\n\t\tcache: cache,\r\n\t\tserializer: serializer,\r\n\t});\r\n}\r\n\r\n//\r\n// Strategy\r\n//\r\n\r\nfunction isPrimitive(value) {\r\n\treturn value == null || typeof value === 'number' || typeof value === 'boolean'; // || typeof value === \"string\" 'unsafe' primitive for our needs\r\n}\r\n\r\nfunction monadic(fn, cache, serializer, arg) {\r\n\tvar cacheKey = isPrimitive(arg) ? arg : serializer(arg);\r\n\r\n\tvar computedValue = cache.get(cacheKey);\r\n\tif (typeof computedValue === 'undefined') {\r\n\t\tcomputedValue = fn.call(this, arg);\r\n\t\tcache.set(cacheKey, computedValue);\r\n\t}\r\n\r\n\treturn computedValue;\r\n}\r\n\r\nfunction variadic(fn, cache, serializer) {\r\n\tvar args = Array.prototype.slice.call(arguments, 3);\r\n\tvar cacheKey = serializer(args);\r\n\r\n\tvar computedValue = cache.get(cacheKey);\r\n\tif (typeof computedValue === 'undefined') {\r\n\t\tcomputedValue = fn.apply(this, args);\r\n\t\tcache.set(cacheKey, computedValue);\r\n\t}\r\n\r\n\treturn computedValue;\r\n}\r\n\r\nfunction assemble(fn, context, strategy, cache, serialize) {\r\n\treturn strategy.bind(context, fn, cache, serialize);\r\n}\r\n\r\nfunction strategyDefault(fn, options) {\r\n\tvar strategy = fn.length === 1 ? monadic : variadic;\r\n\r\n\treturn assemble(fn, this, strategy, options.cache.create(), options.serializer);\r\n}\r\n\r\nfunction strategyVariadic(fn, options) {\r\n\tvar strategy = variadic;\r\n\r\n\treturn assemble(fn, this, strategy, options.cache.create(), options.serializer);\r\n}\r\n\r\nfunction strategyMonadic(fn, options) {\r\n\tvar strategy = monadic;\r\n\r\n\treturn assemble(fn, this, strategy, options.cache.create(), options.serializer);\r\n}\r\n\r\n//\r\n// Serializer\r\n//\r\n\r\nfunction serializerDefault() {\r\n\treturn JSON.stringify(arguments);\r\n}\r\n\r\n//\r\n// Cache\r\n//\r\n\r\nfunction ObjectWithoutPrototypeCache() {\r\n\tthis.cache = Object.create(null);\r\n}\r\n\r\nObjectWithoutPrototypeCache.prototype.has = function (key) {\r\n\treturn key in this.cache;\r\n};\r\n\r\nObjectWithoutPrototypeCache.prototype.get = function (key) {\r\n\treturn this.cache[key];\r\n};\r\n\r\nObjectWithoutPrototypeCache.prototype.set = function (key, value) {\r\n\tthis.cache[key] = value;\r\n};\r\n\r\nvar cacheDefault = {\r\n\tcreate: function create() {\r\n\t\treturn new ObjectWithoutPrototypeCache();\r\n\t},\r\n};\r\n\r\n//\r\n// API\r\n//\r\n\r\nexport default memoize;\r\nexport const strategies = {\r\n\tvariadic: strategyVariadic,\r\n\tmonadic: strategyMonadic,\r\n};\r\n", "import memoize from './memoize';\r\n\r\nexport type DragBoundsCoords = {\r\n\t/** Number of pixels from left of the document */\r\n\tleft: number;\r\n\r\n\t/** Number of pixels from top of the document */\r\n\ttop: number;\r\n\r\n\t/** Number of pixels from the right side of document */\r\n\tright: number;\r\n\r\n\t/** Number of pixels from the bottom of the document */\r\n\tbottom: number;\r\n};\r\n\r\nexport type DragAxis = 'both' | 'x' | 'y' | 'none';\r\n\r\nexport type DragBounds = 'parent' | Partial<DragBoundsCoords> | string;\r\n\r\nexport type DragOptions = {\r\n\t/**\r\n\t * Optionally limit the drag area\r\n\t *\r\n\t * Accepts `parent` as prefixed value, and limits it to its parent.\r\n\t *\r\n\t * Or, you can specify any selector and it will be bound to that.\r\n\t *\r\n\t * **Note**: We don't check whether the selector is bigger than the node element.\r\n\t * You yourself will have to make sure of that, or it may lead to strange behavior\r\n\t *\r\n\t * Or, finally, you can pass an object of type `{ top: number; right: number; bottom: number; left: number }`.\r\n\t * These mimic the css `top`, `right`, `bottom` and `left`, in the sense that `bottom` starts from the bottom of the window, and `right` from right of window.\r\n\t * If any of these properties are unspecified, they are assumed to be `0`.\r\n\t *\r\n\t * @example\r\n\t * ```svelte\r\n\t * <!-- Bound to parent element -->\r\n\t * <div use:draggable={{ bounds: 'parent' }}>\r\n\t *   Hello\r\n\t * </div>\r\n\t * ```\r\n\t *\r\n\t * @example\r\n\t * ```svelte\r\n\t * <!-- Bound to body -->\r\n\t * <div use:draggable={{ bounds: 'body' }}>\r\n\t *   Hello\r\n\t * </div>\r\n\t * ```\r\n\t *\r\n\t * @example\r\n\t * ```svelte\r\n\t * <!-- Bound to arbitrary coordinates -->\r\n\t * <div use:draggable={{ bounds: { top: 100, right: 100, bottom: 100, left: 100 } }}>\r\n\t *   Hello\r\n\t * </div>\r\n\t * ```\r\n\t */\r\n\tbounds?: DragBounds;\r\n\r\n\t/**\r\n\t * Axis on which the element can be dragged on. Valid values: `both`, `x`, `y`, `none`.\r\n\t *\r\n\t * - `both` - Element can move in any direction\r\n\t * - `x` - Only horizontal movement possible\r\n\t * - `y` - Only vertical movement possible\r\n\t * - `none` - No movement at all\r\n\t *\r\n\t * @default 'both'\r\n\t *\r\n\t * @example\r\n\t * ```svelte\r\n\t * <!-- Drag only in x direction -->\r\n\t * <div use:draggable={{ axis: 'x' }}>\r\n\t *   Text\r\n\t * </div>\r\n\t * ```\r\n\t */\r\n\taxis?: DragAxis;\r\n\r\n\t/**\r\n\t * If true, uses `translate3d` instead of `translate` to move the element around, and the hardware acceleration kicks in.\r\n\t *\r\n\t * `true` by default, but can be set to `false` if [blurry text issue](https://developpaper.com/question/why-does-the-use-of-css3-translate3d-result-in-blurred-display/) occur\r\n\t *\r\n\t * @default true\r\n\t *\r\n\t * @example\r\n\t * ```svelte\r\n\t * <!-- Disable GPU acceleration -->\r\n\t * <div use:draggable={{ gpuAcceleration: false }}>\r\n\t *   Text\r\n\t * </div>\r\n\t * ```\r\n\t */\r\n\tgpuAcceleration?: boolean;\r\n\r\n\t/**\r\n\t * Applies `user-select: none` on `<body />` element when dragging,\r\n\t * to prevent the irritating effect where dragging doesn't happen and the text is selected.\r\n\t * Applied when dragging starts and removed when it stops.\r\n\t *\r\n\t * Can be disabled using this option\r\n\t *\r\n\t * @default true\r\n\t *\r\n\t * @example\r\n\t * ```svelte\r\n\t * <!-- Do not disable user selection -->\r\n\t * <div use:draggable={{ applyUserSelectHack: false }}>\r\n\t *   Text\r\n\t * </div>\r\n\t * ```\r\n\t */\r\n\tapplyUserSelectHack?: boolean;\r\n\r\n\t/**\r\n\t * Disables dragging altogether.\r\n\t *\r\n\t * @default false\r\n\t *\r\n\t * @example\r\n\t * ```svelte\r\n\t * <!-- Disable it entirely -->\r\n\t * <div use:draggable={{ disabled: true }}>\r\n\t *   Text\r\n\t * </div>\r\n\t * ```\r\n\t */\r\n\tdisabled?: boolean;\r\n\r\n\t/**\r\n\t * Applies a grid on the page to which the element snaps to when dragging, rather than the default continuous grid.\r\n\t *\r\n\t * `Note`: If you're programmatically creating the grid, do not set it to [0, 0] ever, that will stop drag at all. Set it to `undefined`.\r\n\t *\r\n\t * @default undefined\r\n\t *\r\n\t * @example\r\n\t * ```svelte\r\n\t * <!-- Snap to a grid of 10 by 10 -->\r\n\t * <div use:draggable={{ grid: [10, 10] }}>\r\n\t *   Text\r\n\t * </div>\r\n\t * ```\r\n\t */\r\n\tgrid?: [number, number];\r\n\r\n\t/**\r\n\t * Control the position manually with your own state\r\n\t *\r\n\t * By default, the element will be draggable by mouse/finger, and all options will work as default while dragging.\r\n\t *\r\n\t * But changing the `position` option will also move the draggable around. These parameters are reactive,\r\n\t * so using Svelte's reactive variables as values for position will work like a charm.\r\n\t *\r\n\t *\r\n\t * Note: If you set `disabled: true`, you'll still be able to move the draggable through state variables. Only the user interactions won't work\r\n\t *\r\n\t * Examples:\r\n\t *\r\n\t * [Changing with inputs](https://svelte.dev/repl/e1e707358b37467ba272891715878a1d?version=3.44.1)\r\n\t *\r\n\t * [Changing with Sliders](https://svelte.dev/repl/6b437a1cdbfc4c748520a72330c6395b?version=3.44.1)\r\n\t *\r\n\t * [Draggable only through external state, not user input](https://svelte.dev/repl/0eae169f272e41ba9c07ef222ed2bf66?version=3.44.1)\r\n\t *\r\n\t * [Comes back to original position after drag end](https://svelte.dev/repl/83d3aa8c5e154b7baf1a9c417c217d2e?version=3.44.1)\r\n\t *\r\n\t * [Comes back to original position with transition](https://svelte.dev/repl/bc84ed4ca22f45acbc28de3e33199883?version=3.44.1)\r\n\t */\r\n\tposition?: { x: number; y: number };\r\n\r\n\t/**\r\n\t * CSS Selector of an element inside the parent node(on which `use:draggable` is applied).\r\n\t *\r\n\t * If it is provided, Trying to drag inside the `cancel` selector will prevent dragging.\r\n\t *\r\n\t * @default undefined\r\n\t *\r\n\t * @example\r\n\t * <!-- Grid has a cancel element -->\r\n\t * <div use:draggable={{ cancel: '.cancel' }}>\r\n\t *   Text\r\n\t *   <div class=\"cancel\">This won't drag</div>\r\n\t * </div>\r\n\t * ```\r\n\t */\r\n\tcancel?: string;\r\n\r\n\t/**\r\n\t * CSS Selector of an element inside the parent node(on which `use:draggable` is applied).\r\n\t *\r\n\t * If it is provided, Only clicking and dragging on this element will allow the parent to drag, anywhere else on the parent won't work.\r\n\t *\r\n\t * @default undefined\r\n\t *\r\n\t * @example\r\n\t * <!-- Grid has a handle element -->\r\n\t * <div use:draggable={{ handle: '.handel' }}>\r\n\t *   This won't drag\r\n\t *   <div class=\"handel\">This sure will drag!!</div>\r\n\t * </div>\r\n\t * ```\r\n\t */\r\n\thandle?: string;\r\n\r\n\t/**\r\n\t * Class to apply on the element on which `use:draggable` is applied.\r\n\t * Note that if `handle` is provided, it will still apply class on the parent element, **NOT** the handle\r\n\t *\r\n\t * @default 'svelte-draggable'\r\n\t */\r\n\tdefaultClass?: string;\r\n\r\n\t/**\r\n\t * Class to apply on the parent element when it is dragging\r\n\t *\r\n\t * @default 'svelte-draggable-dragging'\r\n\t */\r\n\tdefaultClassDragging?: string;\r\n\r\n\t/**\r\n\t * Class to apply on the parent element if it has been dragged at least once.\r\n\t *\r\n\t * @default 'svelte-draggable-dragged'\r\n\t */\r\n\tdefaultClassDragged?: string;\r\n\r\n\t/**\r\n   * Offsets your element to the position you specify in the very beginning.\r\n   * `x` and `y` should be in pixels\r\n   *\r\n   \r\n   *\r\n   * @example\r\n   * <!-- Place the element at (300, 200) at the very beginning -->\r\n   * <div use:draggable={{ defaultPosition: { x: 300; y: 200 } }}>\r\n   *   Hello\r\n   * </div>\r\n   * ```\r\n   */\r\n\tdefaultPosition?: { x: number; y: number };\r\n\r\n\t/**\r\n\t * Fires when dragging start\r\n\t */\r\n\tonDragStart?: (data: { offsetX: number; offsetY: number }) => void;\r\n\r\n\t/**\r\n\t * Fires when dragging is going on\r\n\t */\r\n\tonDrag?: (data: { offsetX: number; offsetY: number }) => void;\r\n\r\n\t/**\r\n\t * Fires when dragging ends\r\n\t */\r\n\tonDragEnd?: (data: { offsetX: number; offsetY: number }) => void;\r\n};\r\n\r\nconst DEFAULT_CLASS = {\r\n\tMAIN: 'svelte-draggable',\r\n\tDRAGGING: 'svelte-draggable-dragging',\r\n\tDRAGGED: 'svelte-draggable-dragged',\r\n};\r\n\r\nexport const draggable = (node: HTMLElement, options: DragOptions = {}) => {\r\n\tlet {\r\n\t\tbounds,\r\n\t\taxis = 'both',\r\n\t\tgpuAcceleration = true,\r\n\t\tapplyUserSelectHack = true,\r\n\t\tdisabled = false,\r\n\r\n\t\tgrid,\r\n\r\n\t\tposition,\r\n\r\n\t\tcancel,\r\n\t\thandle,\r\n\r\n\t\tdefaultClass = DEFAULT_CLASS.MAIN,\r\n\t\tdefaultClassDragging = DEFAULT_CLASS.DRAGGING,\r\n\t\tdefaultClassDragged = DEFAULT_CLASS.DRAGGED,\r\n\r\n\t\tdefaultPosition = { x: 0, y: 0 },\r\n\r\n\t\tonDragStart,\r\n\t\tonDrag,\r\n\t\tonDragEnd,\r\n\t} = options;\r\n\r\n\tlet active = false;\r\n\r\n\tlet [translateX, translateY] = [0, 0];\r\n\tlet [initialX, initialY] = [0, 0];\r\n\r\n\t// The offset of the client position relative to the node's top-left corner\r\n\tlet [clientToNodeOffsetX, clientToNodeOffsetY] = [0, 0];\r\n\r\n\tlet [xOffset, yOffset] = [defaultPosition.x, defaultPosition.y];\r\n\r\n\tsetTranslate(xOffset, yOffset, node, gpuAcceleration);\r\n\r\n\tlet canMoveInX: boolean;\r\n\tlet canMoveInY: boolean;\r\n\r\n\tlet bodyOriginalUserSelectVal = '';\r\n\r\n\tlet computedBounds: DragBoundsCoords;\r\n\tlet nodeRect: DOMRect;\r\n\r\n\tlet dragEl: HTMLElement | undefined;\r\n\tlet cancelEl: HTMLElement | undefined;\r\n\r\n\tlet isControlled = !!position;\r\n\r\n\tfunction fireSvelteDragStartEvent(node: HTMLElement) {\r\n\t\tconst data = { offsetX: translateX, offsetY: translateY };\r\n\r\n\t\tnode.dispatchEvent(new CustomEvent('svelte-drag:start', { detail: data }));\r\n\t\tonDragStart?.(data);\r\n\t}\r\n\r\n\tfunction fireSvelteDragStopEvent(node: HTMLElement) {\r\n\t\tconst data = { offsetX: translateX, offsetY: translateY };\r\n\r\n\t\tnode.dispatchEvent(new CustomEvent('svelte-drag:end', { detail: data }));\r\n\t\tonDragEnd?.(data);\r\n\t}\r\n\r\n\tfunction fireSvelteDragEvent(node: HTMLElement, translateX: number, translateY: number) {\r\n\t\tconst data = { offsetX: translateX, offsetY: translateY };\r\n\r\n\t\tnode.dispatchEvent(new CustomEvent('svelte-drag', { detail: data }));\r\n\t\tonDrag?.(data);\r\n\t}\r\n\r\n\tconst listen = addEventListener;\r\n\r\n\tlisten('touchstart', dragStart, false);\r\n\tlisten('touchend', dragEnd, false);\r\n\tlisten('touchmove', drag, false);\r\n\r\n\tlisten('mousedown', dragStart, false);\r\n\tlisten('mouseup', dragEnd, false);\r\n\tlisten('mousemove', drag, false);\r\n\r\n\t// On mobile, touch can become extremely janky without it\r\n\tnode.style.touchAction = 'none';\r\n\r\n\tconst calculateInverseScale = () => {\r\n\t\t// Calculate the current scale of the node\r\n\t\tlet inverseScale = node.offsetWidth / nodeRect.width;\r\n\t\tif (isNaN(inverseScale)) inverseScale = 1;\r\n\t\treturn inverseScale;\r\n\t};\r\n\r\n\tfunction dragStart(e: TouchEvent | MouseEvent) {\r\n\t\tif (disabled) return;\r\n\r\n\t\tnode.classList.add(defaultClass);\r\n\r\n\t\tdragEl = getDragEl(handle, node);\r\n\t\tcancelEl = getCancelElement(cancel, node);\r\n\r\n\t\tcanMoveInX = ['both', 'x'].includes(axis);\r\n\t\tcanMoveInY = ['both', 'y'].includes(axis);\r\n\r\n\t\t// Compute bounds\r\n\t\tif (typeof bounds !== 'undefined') computedBounds = computeBoundRect(bounds, node);\r\n\r\n\t\t// Compute current node's bounding client Rectangle\r\n\t\tnodeRect = node.getBoundingClientRect();\r\n\r\n\t\tif (isString(handle) && isString(cancel) && handle === cancel)\r\n\t\t\tthrow new Error(\"`handle` selector can't be same as `cancel` selector\");\r\n\r\n\t\tif (cancelEl?.contains(dragEl))\r\n\t\t\tthrow new Error(\r\n\t\t\t\t\"Element being dragged can't be a child of the element on which `cancel` is applied\"\r\n\t\t\t);\r\n\r\n\t\tif (dragEl.contains(<HTMLElement>e.target) && !cancelEl?.contains(<HTMLElement>e.target))\r\n\t\t\tactive = true;\r\n\r\n\t\tif (!active) return;\r\n\r\n\t\tif (applyUserSelectHack) {\r\n\t\t\t// Apply user-select: none on body to prevent misbehavior\r\n\t\t\tbodyOriginalUserSelectVal = document.body.style.userSelect;\r\n\t\t\tdocument.body.style.userSelect = 'none';\r\n\t\t}\r\n\r\n\t\t// Dispatch custom event\r\n\t\tfireSvelteDragStartEvent(node);\r\n\r\n\t\tconst { clientX, clientY } = isTouchEvent(e) ? e.touches[0] : e;\r\n\t\tconst inverseScale = calculateInverseScale();\r\n\r\n\t\tif (canMoveInX) initialX = clientX - xOffset / inverseScale;\r\n\t\tif (canMoveInY) initialY = clientY - yOffset / inverseScale;\r\n\r\n\t\t// Only the bounds uses these properties at the moment,\r\n\t\t// may open up in the future if others need it\r\n\t\tif (computedBounds) {\r\n\t\t\tclientToNodeOffsetX = clientX - nodeRect.left;\r\n\t\t\tclientToNodeOffsetY = clientY - nodeRect.top;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction dragEnd(e: MouseEvent | TouchEvent) {\r\n\t\tif (disabled) return;\r\n\t\tif (!active) return;\r\n\r\n\t\t// Apply class defaultClassDragged\r\n\t\tnode.classList.remove(defaultClassDragging);\r\n\t\tnode.classList.add(defaultClassDragged);\r\n\r\n\t\tif (applyUserSelectHack) document.body.style.userSelect = bodyOriginalUserSelectVal;\r\n\r\n\t\tfireSvelteDragStopEvent(node);\r\n\r\n\t\tif (canMoveInX) initialX = translateX;\r\n\t\tif (canMoveInX) initialY = translateY;\r\n\r\n\t\tactive = false;\r\n\t}\r\n\r\n\tfunction drag(e: TouchEvent | MouseEvent) {\r\n\t\tif (!active) return;\r\n\r\n\t\t// Apply class defaultClassDragging\r\n\t\tnode.classList.add(defaultClassDragging);\r\n\r\n\t\te.preventDefault();\r\n\r\n\t\tnodeRect = node.getBoundingClientRect();\r\n\r\n\t\tconst { clientX, clientY } = isTouchEvent(e) ? e.touches[0] : e;\r\n\r\n\t\t// Get final values for clamping\r\n\t\tlet [finalX, finalY] = [clientX, clientY];\r\n\r\n\t\tconst inverseScale = calculateInverseScale();\r\n\r\n\t\tif (computedBounds) {\r\n\t\t\t// Client position is limited to this virtual boundary to prevent node going out of bounds\r\n\t\t\tconst virtualClientBounds: DragBoundsCoords = {\r\n\t\t\t\tleft: computedBounds.left + clientToNodeOffsetX,\r\n\t\t\t\ttop: computedBounds.top + clientToNodeOffsetY,\r\n\t\t\t\tright: computedBounds.right + clientToNodeOffsetX - nodeRect.width,\r\n\t\t\t\tbottom: computedBounds.bottom + clientToNodeOffsetY - nodeRect.height,\r\n\t\t\t};\r\n\r\n\t\t\tfinalX = Math.min(Math.max(finalX, virtualClientBounds.left), virtualClientBounds.right);\r\n\t\t\tfinalY = Math.min(Math.max(finalY, virtualClientBounds.top), virtualClientBounds.bottom);\r\n\t\t}\r\n\r\n\t\tif (Array.isArray(grid)) {\r\n\t\t\tlet [xSnap, ySnap] = grid;\r\n\r\n\t\t\tif (isNaN(+xSnap) || xSnap < 0)\r\n\t\t\t\tthrow new Error('1st argument of `grid` must be a valid positive number');\r\n\r\n\t\t\tif (isNaN(+ySnap) || ySnap < 0)\r\n\t\t\t\tthrow new Error('2nd argument of `grid` must be a valid positive number');\r\n\r\n\t\t\tlet [deltaX, deltaY] = [finalX - initialX, finalY - initialY];\r\n\t\t\t[deltaX, deltaY] = snapToGrid(\r\n\t\t\t\t[Math.floor(xSnap / inverseScale), Math.floor(ySnap / inverseScale)],\r\n\t\t\t\tdeltaX,\r\n\t\t\t\tdeltaY\r\n\t\t\t);\r\n\r\n\t\t\tif (!deltaX && !deltaY) return;\r\n\r\n\t\t\t[finalX, finalY] = [initialX + deltaX, initialY + deltaY];\r\n\t\t}\r\n\r\n\t\tif (canMoveInX) translateX = (finalX - initialX) * inverseScale;\r\n\t\tif (canMoveInY) translateY = (finalY - initialY) * inverseScale;\r\n\r\n\t\t[xOffset, yOffset] = [translateX, translateY];\r\n\r\n\t\tfireSvelteDragEvent(node, translateX, translateY);\r\n\r\n\t\tPromise.resolve().then(() => setTranslate(translateX, translateY, node, gpuAcceleration));\r\n\t}\r\n\r\n\treturn {\r\n\t\tdestroy: () => {\r\n\t\t\tconst unlisten = removeEventListener;\r\n\r\n\t\t\tunlisten('touchstart', dragStart, false);\r\n\t\t\tunlisten('touchend', dragEnd, false);\r\n\t\t\tunlisten('touchmove', drag, false);\r\n\r\n\t\t\tunlisten('mousedown', dragStart, false);\r\n\t\t\tunlisten('mouseup', dragEnd, false);\r\n\t\t\tunlisten('mousemove', drag, false);\r\n\t\t},\r\n\t\tupdate: (options: DragOptions) => {\r\n\t\t\t// Update all the values that need to be changed\r\n\t\t\taxis = options.axis || 'both';\r\n\t\t\tdisabled = options.disabled ?? false;\r\n\t\t\thandle = options.handle;\r\n\t\t\tbounds = options.bounds;\r\n\t\t\tcancel = options.cancel;\r\n\t\t\tapplyUserSelectHack = options.applyUserSelectHack ?? true;\r\n\t\t\tgrid = options.grid;\r\n\t\t\tgpuAcceleration = options.gpuAcceleration ?? true;\r\n\r\n\t\t\tconst dragged = node.classList.contains(defaultClassDragged);\r\n\r\n\t\t\tnode.classList.remove(defaultClass, defaultClassDragged);\r\n\r\n\t\t\tdefaultClass = options.defaultClass ?? DEFAULT_CLASS.MAIN;\r\n\t\t\tdefaultClassDragging = options.defaultClassDragging ?? DEFAULT_CLASS.DRAGGING;\r\n\t\t\tdefaultClassDragged = options.defaultClassDragged ?? DEFAULT_CLASS.DRAGGED;\r\n\r\n\t\t\tnode.classList.add(defaultClass);\r\n\r\n\t\t\tif (dragged) node.classList.add(defaultClassDragged);\r\n\r\n\t\t\tif (isControlled) {\r\n\t\t\t\txOffset = translateX = options.position?.x ?? translateX;\r\n\t\t\t\tyOffset = translateY = options.position?.y ?? translateY;\r\n\r\n\t\t\t\tPromise.resolve().then(() => setTranslate(translateX, translateY, node, gpuAcceleration));\r\n\t\t\t}\r\n\t\t},\r\n\t};\r\n};\r\n\r\nfunction isTouchEvent(event: MouseEvent | TouchEvent): event is TouchEvent {\r\n\treturn Boolean((event as TouchEvent).touches && (event as TouchEvent).touches.length);\r\n}\r\n\r\nfunction isString(val: unknown): val is string {\r\n\treturn typeof val === 'string';\r\n}\r\n\r\nconst snapToGrid = memoize(\r\n\t([xSnap, ySnap]: [number, number], pendingX: number, pendingY: number): [number, number] => {\r\n\t\tconst x = Math.round(pendingX / xSnap) * xSnap;\r\n\t\tconst y = Math.round(pendingY / ySnap) * ySnap;\r\n\t\treturn [x, y];\r\n\t}\r\n);\r\n\r\nfunction getDragEl(handle: string | undefined, node: HTMLElement) {\r\n\tif (!handle) return node;\r\n\r\n\t// Valid!! Let's check if this selector exists or not\r\n\tconst handleEl = node.querySelector<HTMLElement>(handle);\r\n\tif (handleEl === null)\r\n\t\tthrow new Error(\r\n\t\t\t'Selector passed for `handle` option should be child of the element on which the action is applied'\r\n\t\t);\r\n\r\n\treturn handleEl!;\r\n}\r\n\r\nfunction getCancelElement(cancel: string | undefined, node: HTMLElement) {\r\n\tif (!cancel) return;\r\n\r\n\tconst cancelEl = node.querySelector<HTMLElement>(cancel);\r\n\r\n\tif (cancelEl === null)\r\n\t\tthrow new Error(\r\n\t\t\t'Selector passed for `cancel` option should be child of the element on which the action is applied'\r\n\t\t);\r\n\r\n\treturn cancelEl;\r\n}\r\n\r\nfunction computeBoundRect(bounds: string | Partial<DragBoundsCoords>, rootNode: HTMLElement) {\r\n\tif (typeof bounds === 'object') {\r\n\t\t// we have the left right etc\r\n\t\tconst [windowWidth, windowHeight] = [window.innerWidth, window.innerHeight];\r\n\r\n\t\tconst { top = 0, left = 0, right = 0, bottom = 0 } = bounds;\r\n\r\n\t\tconst computedRight = windowWidth - right;\r\n\t\tconst computedBottom = windowHeight - bottom;\r\n\r\n\t\treturn { top, right: computedRight, bottom: computedBottom, left };\r\n\t}\r\n\r\n\t// It's a string\r\n\tif (bounds === 'parent') return (rootNode.parentNode as HTMLElement).getBoundingClientRect();\r\n\r\n\tconst node = document.querySelector<HTMLElement>(bounds);\r\n\r\n\tif (node === null)\r\n\t\tthrow new Error(\"The selector provided for bound doesn't exists in the document.\");\r\n\r\n\tconst computedBounds = node!.getBoundingClientRect();\r\n\r\n\treturn computedBounds;\r\n}\r\n\r\nfunction setTranslate(xPos: number, yPos: number, el: HTMLElement, gpuAcceleration: boolean) {\r\n\tel.style.transform = gpuAcceleration\r\n\t\t? `translate3d(${+xPos}px, ${+yPos}px, 0)`\r\n\t\t: `translate(${+xPos}px, ${+yPos}px)`;\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
